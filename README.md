# algo_labs
# Лабораторні роботи з дисципліни "Алгоритмів і структур даних"
## Виконав: Трускавецький Богдан васильович (Група ІР-23)
### Лабораторна робота №1 (Варіант 2 Рівень 1)
Дано масив цілих чисел nums та ціле число target. Перевірте, чи існують два різних елементи в масиві nums, сума яких дорівнює target. Якщо такі елементи існують, поверніть індекси цих елементів.

Припустимо, що кожен масив цілих чисел nums може мати більше одного рішення, або жодного, і той самий елемент не може бути використаний двічі. Якщо масив не містить двох чисел, сума яких рівна target - тоді слід повернути значення -1

Приклади:

Вхідні дані: nums = [2,7,11,15], target = 9 Результат: [0,1] Пояснення: Елементи nums [0] + nums[1] = 2 + 7 = 9, їх сума рівна target.

Вхідні дані: nums = [3,2,4], target = 6 Результат: [1,2] Пояснення: Елементи nums[1] + nums[2] = 2 + 4 = 6, їх сума рівна target.

Вхідні дані: nums = [3,3], target = 6 Результат: [0,1] Пояснення: Елементи nums[0] + nums[1] = 3 + 3 = 6, їх сума рівна target.

Вхідні дані: nums = [3,5], target = 6 Результат: -1 Пояснення: Немає елементів, сума яких рівна target.

Для перевірки виконання роботи реалізованого алгоритму слід використати бібліотеку unittest та перевірити роботу вашої функції на прикладах, наведених вище


### Лабораторна робота №2 (Варіант 2 Рівень 1)
Припустимо, компанія, в якій ви працюєте, розробляє електронний календар. У календарі є функція, що показує, коли різні команди програмістів будуть зайняті протягом будь-якої зустрічі.

Ті періоди, коли команда зайнята, на календарі позначені як діапазони часу, наприклад, з 10:00 до 12:30 або з 12:30 до 13:00. У вашій програмі проміжок часу представлений у вигляді пари з двох цілих чисел. Число означає номер 30-хвилинного блоку, який йде після 9:00 ранку. Наприклад, кортеж (2, 4) означає діапазон з 10:00 до 11:00, а (0, 1) - це проміжок 9:00-9:30.

Вам потрібно написати функцію, яка повинна спростити вивід інформації таким чином, що якщо команда зайнята в проміжках з 10:00 до 12:30 і з 12:30 до 13:00, то це має відображатись  як 10: 00-13: 00.

Приклад:

на вході вашої функції невпорядкований масив з кортежів [(0, 1), (3, 5), (4, 8), (10, 12), (9, 10)],

Результат: Ваша функція має повернути впорядкований масив [(0, 1), (3, 8), (9, 12)].

Для перевірки виконання роботи реалізованого алгоритму слід використати бібліотеку unittest та перевірити роботу вашої функції на прикладах, наведених вище


### Лабораторна робота №3 (Варіант 2 Рівень 1)
Існує три найпоширеніші способи проходження бінарних дерев вглиб: прямий (pre-order), зворотній (post-order) та серединний (in-order).

Реалізуйте функцію, яка отримує на вхід вершину бінарного дерева та виконує його зворотній обхід (Post-order traversal) та повертає значення вузлів у списку у відповідному порядку.

Розглянемо таке бінарне дерево:

    1
   / \
  2    3
   \  / \
   5  6  7
Під час прямого обходу це дерево буде відвідане в такому порядку: [5, 2, 6, 7, 3, 1]

Функція post_order_traversal(root: BinaryTree) -> List отримує на вхід корінь бінарного дерева, який має наступний вигляд:

class BinaryTree:
    def __init__(self, value, left=None, right=None, parent=None):
        self.value = value
        self.left = left
        self.right = right
Реалізація даної задачі не вимагає написання коду вставки чи виділення елементів з бінарного дерева. У тесті ви можете створити достатню кількість елементів класу BinaryTree наступним чином:

root = BinaryTree(3)
root.left = BinaryTree(9)
root.right = BinaryTree(20)


### Лабораторна робота №4 (Варіант 1 Рівень 1)
Реалізуйте структуру даних "черга з пріоритетами" на основі двозв'язаного списку, в якому кожен елемент має значення та пріоритет в списку і додається в список, впорядкований за пріоритетами.

Кожен елемент черги має відноситися до певного пріоритету. Елементи з більшим пріоритетом мають бути доступні в чергу раніше, ніж елементи з меншим пріоритетом. Якщо у двох елементів однаковий пріоритет, то вони вставляються у порядку їх додавання.

Операції, які підтримує ваша черга:

Вставка елемента з заданим значенням та пріоритетом до черги.
Видалення та повернення елемента з найвищим пріоритетом з черги.
Перегляд черги без її зміни.
Для реалізації такої черги з пріоритетами можна використати двозв'язаний список, де кожен елемент буде мати два поля: значення та пріоритет. При вставці елемента до черги, його потрібно розмістити у відповідному порядку з урахуванням пріоритету. При видаленні елемента з найвищим пріоритетом, просто видаляємо перший елемент зі списку.

Реалізація цієї задачі передбачає написання власної структури "двозв'язаний список". Назва файлу реалізації - list_based_priority_queue.py


### Лабораторна робота №5 (Варіант 2 Рівень 2)
Кар’єра 88999
Код задачi: CAREER
Ви хочете зробити кар’єру у великiй корпорацiї, яка має складну iєрархiчну структуру
та багато посад. Проте, читаючи вiдгуки працiвникiв на GlassDoor, ви дiзнаєтеся,
що рiзнi посади в цiй компанiї приносять зовсiм рiзну кiлькiсть корисного досвiду,
тому є сенс ретельно обирати, на яких посадах ви хочете працювати.
Органiзацiйна структура компанiї має форму пiрамiди, де вищий рiвень має рiвно
на 1 посаду менше, нiж нижчий. Досвiд, який можна здобути на кожнiй посадi, а
також способи пiдвищення вказанi на схемi:
4

3 1

2 1 5

1 3 2 1

Працiвник може бути переведений тiльки на вищу посаду (з вищої на нижчу рухатись
не дозволяється).
Знаючи досвiд, який можна здобути на кожнiй посадi в компанiї, визначте максимальну
суму досвiду, яку ви можете здобути, почавши працювати на найнижчому рiвнi.
Вхiднi данi
Вхiдний файл career .in складається з L + 1 рядкiв.
• Перший рядок мiстить L — кiлькiсть органiзацiйних рiвнiв в компанiї.
1 ≤ L ≤ 1000
• Наступнi L рядкiв мiстять 1, 2, 3, ..., L−2, L−1, L натуральних чисел E — досвiд
для кожної посади на даному рiвнi.
0 ≤ E < 10000
Вихiднi данi
Вихiдний файл career .out повинен мiстити одне цiле число — максимальний сумарний
досвiд, який можливо здобути в цiй компанiї.


### Лабораторна робота №6 (Варіант 2 Рівень 2)
Створити функцію на мові програмування Python, яка приймає дві стрічки: "haystack" (довільний текст) та "needle" (шукана стрічка). Програма повинна знайти індекси всіх входжень стрічки "needle" в стрічці "haystack" та повернути цей індекс, використовуючи  метод Боєра-Мура для пошуку підстрічки у стрічці
